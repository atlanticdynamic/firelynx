# Extism WASM Script App Example Configuration
# Demonstrates how to use WebAssembly plugins for high-performance request processing.
#
# Extism allows running WASM modules compiled from various languages (Rust, Go, C++, etc.)
# This example uses a Rust-compiled vowel counting plugin embedded as base64.
#
# WASM Source: examples/wasm/rust/char_counter/ (Rust plugin using XTP/Extism PDK)
# To rebuild WASM: cd examples/wasm/rust/char_counter && make build
# To get base64: base64 -i target/wasm32-wasip1/release/plugin.wasm
#
# For production, you can use either:
# - code = "base64-encoded-wasm-here" (self-contained, good for testing)
# - uri = "file://path/to/plugin.wasm" (file reference, good for production)

version = "v1"

# HTTP Listener Configuration
[[listeners]]
id = "http"
address = ":8080"
type = "http"

[listeners.http]
read_timeout = "30s"
write_timeout = "30s"

# Endpoint Configuration
[[endpoints]]
id = "main"
listener_id = "http"

# Route Configuration
# Note: static_data can be defined at both app and route levels
# Route-level static_data overrides app-level for specific keys

# Route 1: Count only the letter 'z' or 'Z' at /api/z-counter
[[endpoints.routes]]
app_id = "demo-counter"
[endpoints.routes.http]
path_prefix = "/api/z-counter"
# Route-specific configuration to count only 'z' letters
[endpoints.routes.static_data]
search_characters = "zZ"
match_description = "z letters"
case_sensitive = false

# Route 2: Count vowels (default) at /api/vowel-counter  
[[endpoints.routes]]
app_id = "demo-counter"
[endpoints.routes.http]
path_prefix = "/api/vowel-counter"
# No static_data here - will use app-level defaults (vowels)

# Route 3: Original demo route (uses app-level config for vowels)
[[endpoints.routes]]
app_id = "demo-counter"
[endpoints.routes.http]
path_prefix = "/api/demo"

# Extism WASM Script Application
[[apps]]
id = "demo-counter"

[apps.script]
# Static data available to the WASM plugin
[apps.script.static_data]
service_name = "firelynx-extism-demo"
version = "1.0.0"
plugin_language = "rust"
description = "Configurable character counting WASM demo"

# Character matching configuration
search_characters = "aeiouAEIOU"  # Characters to count in request body
match_description = "vowels"      # Description of what we're counting
case_sensitive = false            # Whether matching is case-sensitive

# Alternative examples (uncomment to try different configurations):
# search_characters = "bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ"  # Consonants
# match_description = "consonants"
# search_characters = "0123456789"   # Digits
# match_description = "digits"
# search_characters = "!@#$%^&*()"   # Special characters
# match_description = "special_chars"

# Extism evaluator configuration
[apps.script.extism]
# Configurable character counting WASM plugin
uri = "file:///Users/rterhaar/Dropbox/research/golang/firelynx/examples/wasm/rust/char_counter/target/wasm32-wasip1/release/plugin.wasm"
entrypoint = "CountCharacters"
timeout = "5s"

# Note: This minimal WASM returns a simple value for demonstration.
# For real applications, build your WASM plugin from Rust, Go, or other languages
# and reference it with: uri = "file://path/to/plugin.wasm"
#
# Example production usage:
# uri = "file://examples/wasm/rust/char_counter/target/wasm32-wasip1/release/plugin.wasm"
# entrypoint = "CountCharacters"